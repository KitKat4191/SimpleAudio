
using UnityEngine;

namespace KitKat.SimpleAudio.Runtime
{
    [System.Serializable]
    [HelpURL("https://docs.unity3d.com/2022.3/Documentation/Manual/class-AudioSource.html")]
    public class Sound : ISerializationCallbackReceiver
    {
        #region SERIALIZED FIELDS
        
        [Header("Settings")]
        [SerializeField]
        [Tooltip("The name you use to play or stop the sound via the AudioManager")]
        private string name;

        [SerializeField]
        [Tooltip("The audio clip to play")]
        private AudioClip clip;

        [Space]
        [SerializeField]
        [Tooltip("Bypass effects? (Applied from filter components or global listener filters).")]
        private bool bypassEffects;
        
        [SerializeField]
        [Tooltip("When set, global effects on the AudioListener doesn't apply to the audio signal generated by the AudioSource. It also doesn't apply, if the AudioSource is playing into a mixer group.")]
        private bool bypassListenerEffects;
        
        [SerializeField]
        [Tooltip("When set, it doesn't route the signal from an AudioSource into the global reverb associated with reverb zones.")]
        private bool bypassReverbZones;
        
        [SerializeField]
        [Tooltip("Should the sound play again when it reaches the end?")]
        private bool loop;
        
        [Space]
        [Range(0, 255)]
        [SerializeField]
        [Tooltip("Priority: 0 = most important. 255 = least important. Default = 128. Use 0 for things like music.")]
        private byte priority;
        
        [Range(0f, 1f)]
        [SerializeField]
        [Tooltip("The volume at which the sound is played.")]
        private float volume;
        
        [Range(-3f, 3f)]
        [SerializeField]
        [Tooltip("The pitch at which the sound is played. maxPitchVariation changes the pitch relative to this value.")]
        private float pitch;

        [Range(0f, 0.25f)]
        [SerializeField]
        [Tooltip("This value should be very very small. It has a massive impact.")]
        private float maxPitchVariation;

        #endregion // SERIALIZED FIELDS
        
        #region PRIVATE FIELDS
        
        private AudioSource _source;

        #endregion // PRIVATE FIELDS

        
        #region API
        
        /// <summary>
        /// Support adjusting values while in editor play mode.
        /// </summary>
        public void OnValidate() => SetAudioSource(_source);
        
        public void SetAudioSource(AudioSource source)
        {
            if (!source) return;
            
            _source = source;

            _source.clip = clip;
            
            _source.bypassEffects = bypassEffects;
            _source.bypassListenerEffects = bypassListenerEffects;
            _source.bypassReverbZones = bypassReverbZones;
            
            _source.playOnAwake = false;
            _source.loop = loop;
            
            _source.priority = priority;
            _source.volume = volume;
            _source.pitch = pitch;
        }

        public string Name => name;

        public void Play()
        {
            _source.pitch = Random.Range(pitch - maxPitchVariation, pitch + maxPitchVariation);
            _source.Play();
        }

        public void Stop()
        {
            _source.Stop();
        }
        
        #endregion // API

        #region SCUFFED
        
        public void OnBeforeSerialize() { }

        public void OnAfterDeserialize() => SetDefaultValues();

        // Store this flag in the scene so we can access it later but hide it from the inspector.
        [SerializeField, HideInInspector] private bool hasBeenReset;
        
        /// <summary>
        /// If you're wondering why the fuck this is here it's because Unity still hasn't
        /// implemented support for default values on custom Serializable classes.
        /// See: https://discussions.unity.com/t/default-values-for-serializable-class-not-supported/408349/21
        /// The solution here was to hook into the ISerializationCallbackReceiver and manually
        /// write the desired default values on the first serialization.
        ///
        /// Alternatively one could define a custom inspector and create a ReorderableList to wrap the sequential container.
        /// then simply plug your custom behaviour in the onAddCallback event.
        /// Unity’s native behaviour is to copy the last element if any, so you should probably implement that too.
        /// </summary>
        private void SetDefaultValues()
        {
            if (hasBeenReset) return;
            hasBeenReset = true;

            name = string.Empty;
            clip = null;
            bypassEffects = false;
            bypassListenerEffects = false;
            bypassReverbZones = false;
            loop = false;
            priority = 128;
            volume = 1f;
            pitch = 1f;
            maxPitchVariation = 0f;
        }

        #endregion // SCUFFED
    }
}